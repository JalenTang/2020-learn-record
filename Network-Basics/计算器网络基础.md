# 计算器网络基础

## TCP/IP

- TCP：传输控制协议（Transmission Control Protocol）
- IP：网际协议（Internet Protocol）

## HTTP

- HTTP：超文本传输 ​​ 协议（Hypertext Transfer Protoco），一个用于分布式、协作式和超媒体信息系统的**应用层**协议
- HTTP 基于 TCP/IP 通信协议来传输数据，是一个标准的**B/S（brower 浏览器/server 服务端）**模型，HTTP 协议总是由 HTTP 客户端向 HTTP 服务端发起请求
- 主要特点：

1. 简单快捷：客户端向服务器请求服务时，只需传送请求方法和路径
2. 灵活：HTTP 允许传输任意类型的数据对象，类型由 `Content-Type` 加以标记
3. 短连接/长连接/管道化/多路复用：

    - HTTP/0.9 时代：**短连接**，即每次 HTTP 请求都要经历一次 DNS 解析，TCP 连接

    - HTTP/1.0 时代：提出**持久连接**，即一次 TCP 连接服务多个请求，客户端通过添加请求头`Connection: Keep-Alive`向服务器请求持久连接；如果服务器支持持久连接，会在响应头里返回`Connection: Keep-Alive`，默认参数是`{timeout=5, max=100}`, 即一个 TCP 连接可以服务至多 5 秒内的 100 次请求

    - HTTP/1.1 时代：默认持久连接，不需要在请求头中携带`Connection: Keep-Alive`；并且提出**pipelining**概念来试图解决**HOLB（Head of Line Blocking）**问题，即客户端可以在一个请求发送完成后不等待响应便直接发起第二个请求，服务端在返回响应时会按请求到达的顺序依次返回；但管道化并没有彻底解决 HOLB，为了让同一个连接中的多个响应能够和多个请求匹配上，响应仍然是按请求的顺序串行返回的

    - HTTP/2 时代： **多路复用 multiplexing**，即让多个请求和响应的传输完全混杂在一起进行，通过`streamId`来互相区别，同时还允许给每个请求设置优先级，服务端会先响应优先级高的请求 - **HPACK 算法**，即对 HTTP 头部字段做数据压缩 4. 无状态（stateless）：对于发送过的请求和响应都不做持久化处理，但是可以通过**Cookies/Session**来实现有状态的会话

### HTTP 报文

- 请求报文

    1. 由**请求行**、**请求头**、**空行**和**请求体**组成
    2. 请求行包括**请求方法**、**请求 URL**和**HTTP/版本号**

- 响应报文

    1. 由**响应行**、**响应头**、**空行**和**响应体**组成
    2. 响应行包括**HTTP/版本号**、**状态码**和**状态码描述**

- 常见的头部字段:

    1. `Accept-Encoding:gzip/compress/deflate/identity(默认)`, 表示客户端支持的内容编码格式，可取值：
    2. `Authorization`：表示客户端的认证信息，一般和 JWT 连用
    3. `Access-Control-Allow-Methods`：指定客户端访问允许使用的方法或方法列表
    4. `Access-Control-Allow-Origin`：指定响应的资源是否被允许与给定的 origin 共享，设置为`*`来允许跨域
    5. `Access-Control-Max-Age`：指定预检请求 preflight request 的返回结果可以被缓存的时间，值为-1 表示禁用缓存
    6. `ETag`：表示资源的特定版本的标识符，不同的资源对应不用的 ETag 值，便于高效化浏览器缓存机制
    7. `If-None-Match`：指定上次服务器返回的资源的标识符，请求头携带此字段，服务器根据该值判断资源是否发生改变
    8. `Expires：<http-date>`，指定请求过期的日期/时间，如：`Expires: Wed, 21 Oct 2020 07:28:00 GMT`;
    9. `Cache-Control：no-cache/no-store/public/private/max-age=<>`，HTTP/1.1 的新增字段，用于判断浏览器缓存控制规则，优先级高于 Expires
    10. `Last-Modified`：指定源头服务器认定的资源做出修改的日期及时间，如：`Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT`
    11. `If-Modified-Since`：浏览器再次请求资源时携带的时间值，服务器根据该值判断是否返回新的资源，只在 `GET` 和 `HEAD` 方法中有效
    12. Keep-Alive：
    13. User-Agent：保护浏览器和代理名称等信息
    14. Set-Cookie
    15. Cookie：

### HTTP 请求方法

1. GET
2. POST
3. PUT
4. DELETE
5. OPTIONS
6. TRACE
7. CONNECT

### HTTP 状态码

1. 1xx: 表示信息响应(information response)
   - `100 Continue`:
2. 2xx: 表示成功响应(successful)
3. 3xx: 表示重定向(redirection)
4. 4xx: 表示客户端错误
5. 5xx: 表示服务器错误

### 浏览器缓存机制

#### 浏览器缓存：重用已获取的资源，减少延迟与网络阻塞，有利于提升网站与应用的性能

#### 浏览器缓存过程：![浏览器缓存机制](../images/network-cache.png)

- 当浏览器发起一个请求：
  - 是否存在本地缓存， - 不存在：直接发起请求 - 存在：根据**强缓存策略**判断是否过期： - 未过期：直接载入缓存资源 - 已过期：根据**协商缓存策略**判断缓存是否有效， - 有效：则返回 304 状态码，载入缓存资源 - 无效：重新请求服务器

1. 强缓存相关字段：

   - `Expires`：**HTTP/1.0**的字段，弃置为服务器返回请求过期的时间，表示在该时间之前，本地缓存始终有效

   - `Cache-Control`：**HTTP/1.1**的字段，优先级高于`Expires`，可选的值有：

     ```

     缓存
     内容
     务器
     缓存
     - `max-age=<seconds>`：缓存到期的最大周期（相对时间），超过该事件则任务过期
     ```

   - **注意点**：由于`Expires`时间返回的是服务器绝对时间，而客户端本地时间是可以修改的，因此会造成时间的误差和不同步，而`Cache-Control:max-age=<seconds>`返回的是参照客户端第一次请求的相对时间，因此不会受到影响

2. 协商缓存相关字段：

   - 第一组： `Last-Modified` 和 `If-Modify-Since`，浏览器第一次请求服务器资源时，服务器会在响应头内设置`Last-Modified`字段，表示该资源最后修改的时间；浏览器第二次请求资源时，会在请求头内设置`If-Modify-Since`，其值为上一次的`Last-Modified`值，服务器收到`If-Modify-Since`的值后，比服务器资源的`Last-Modified`作比较，

     ```

     - 如果无变化则返回`304`，不返回资源，不返回`Last-Modified`值，浏览器接收`304`后使用本地缓存
     ```

   - 第二组：`ETag` 和 `If-None-Match`，浏览器第一次请求服务器资源时，服务器会在响应头内设置`ETag`字段，其值表示该资源的唯一标识符；浏览器第二次请求资源时，会在请求头内设置`If-None-Match`，其值为上一次响应头的`ETag`值，服务器收到`If-None-Match`的值后，与服务器资源的`ETag`作比较:

     ```

     - 如果两者一致，则说明资源未发生改变，返回`304`，不返回资源，**返回`ETag`值（即使未变化）**，浏览器接收`304`后使用本地缓存
     ```

   - **注意点**：上述两者是可以一起使用的，但是 `ETag` 的优先级高于 `Last-Modified`，`ETag` 一致的情况下，再比对`Last-Modified` - `ETag` 解决了某些时候，文件未发生改变，但是修改时间发生改变而不需要重新返回新资源的问题 - `If-Modified-Since`是秒级的，对于频繁修改的文件识别不准确，比如某个资源 1s 内修改了多次

### HTTP 和 HTTPS

### HTTP 参考文章

1. [HTTP 维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)
2. [MDN HTTP Headers 全解](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)
3. [浏览器缓存](https://juejin.im/post/5c4528a6f265da611a4822cc#heading-18)
4. [HTTP 和 HTTPS](https://juejin.im/post/5af557a3f265da0b9265a498#heading-14)

## 浏览器存储相关 Cookie/localStorage/sessionStorage/indexedDB

### Cookie

#### 简介

1. 服务器发送到用户浏览器并保存在本地的数据，会在浏览器下次向同一服务器发起请求时被携带并发送到服务器
2. Cookie 使得基于无状态的 HTTP 协议记录状态成为可能
3. Cookie 主要用于：
   - 会话状态管理（用户登录状态、购物车、游戏分数等需要记录的信息）
   - 个性化设置（用户自定义设置、主题）
   - 浏览器行为跟踪
4. Cookie 用于客户端数据的存储已经其他本地存储技术淘汰，因为每次请求都会携带 Cookie 会造成额外的性能开销
5. Cookie 存储上限是 **4K**

#### 属性介绍

1. Cookie 通常由服务端通过设置响应头`Set-Cookie：<key>=<value>`的形式保存到浏览器；
2. 浏览器通常在请求头以`Cookie:<key1>=<value1>;<key2>=<value2>`的形式发送给服务端完成信息交流；
3. 其他重要的属性：
   - `Expires`：设置特定的过期时间，绝对时间，如：`Expires=Wed, 31 Mar 2020 18:00:00 GMT;`
   - `Max-Age`：设置有效期，单位是秒，相对时间，如：`Max-Age: 86400`表示一天后过期
   - `Secure`：标记为 Secure 的 cookie 只能通过 HTTPS 协议加密发送，只在 https 站点适用
   - `HttpOnly`：为避免`XSS`（跨域脚本攻击），`Document.cookie`无法访问带有`HttpOnly`标记的 Cookie
   - `SameSite`：为阻止`CSRF`（跨站请求伪造攻击），可取值为： - `None`：自动携带，浏览器会在**同站请求和跨站请求**下继续发送 cookies - `Strict`：浏览器将只发送**相同站点**请求的 cookie - `Lax`：目前新版本浏览器的默认值，阻止一些跨站子请求发送 Cookie， - 不发送 Cookie: 图片加载、iframe 等等 - 发送 Cookie：点击`<a>`标签、发送 GET 表单等等

#### Cookie 参考文章

1. [MDN Cookie 介绍](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)
2. [惊艳面试官的 Cookie 介绍](https://juejin.im/post/5e57a3ff6fb9a07cb1578d12)
3. [封装的 js-cookie 库](https://github.com/js-cookie/js-cookie)

### localStorage 和 sessionStorage

1. 相同点：

   - 都是存储在**浏览器本地**的
   - 存储的数据大小都为**5M**左右
   - 接口 API 封装完整，可以直接使用
   - 数据均以字符串键值对的形式存储

2. 不同点：`localStorage`和`sessionStorage`有 2 个最大的区别

   - 生命周期不同，`sessionStorage`是会话级别的存储，其保存的数据基于浏览器的一次会话，当会话结束（通常是关闭该窗口），数据即被清空；而`localStorage`是持久化的本地存储，除非手动清除，否则会一直保留在浏览器，即使浏览器关闭
   - `localStorage`可以在同源地址下 share 同一份数据，而`sessionStorage`则还需要同一窗口

3. API 使用

   - 返回保存的数据项个数：`Storage.length`
   - 设置 Storage：`Storage.setItem(key, value)`， 如`localStorage.setItem('name', 'Jalen')`
   - 读取 Storage：`Storage.getItem(key)`， 如`localStorage.getItem('name')`
   - 清除 Storage：`Storage.removeItem(key)`， 如`localStorage.removeItem('name')`
   - 清空 Storage：`Storage.clear()`
   - 监听 storage 的变化：在同一个页面内发生的改变不会起作用，在相同域名下的其他页面（如一个新标签或 iframe）发生的改变才会起作用

   ```javascript
   window.addEventListener('storage', (e) => {
   )
   })
   ```

### indexedDB

1. indexedDB 是一个用于在浏览器中储存较大数据结构的 Web API，使用**索引**来实现对该数据的高性能搜索
2. IndexedDB 是一个事务型数据库系统，基于 JavaScript 面向对象以**键值对**的形式存储
3. IndexedDB 是异步的，遵循同源策略

## 鉴权相关 Cookies/Session/Token/JWT 的区别

## 浏览器安全相关

### XSS 和 CSRF

### Cookies：同上

## 跨域
