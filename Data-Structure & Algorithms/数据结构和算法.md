# 数据结构与算法 Data Structure and Algorithms

## 栈 Stack

1. 后进先出(LIFO, Last In - First Out)

## 队列 Queue

## 链表 LinkedList

## 树 Tree

## 广度优先遍历（BFS）和 深度优先遍历（DFS）

<img src="../images/BFS和DFS.png" width="400" height="200" alt="无向图" style="zoom:150%;" />

### BFS: 广度优先遍历 Breadth First Search

1. 广度优先遍历一层一层地进行遍历，每层遍历都将上一层遍历的结果为起点，遍历过的节点不再遍历
2. 在上图所示的无向图中，BFS的遍历顺序为：**1，2，3，4，5，6，7，8，9**
3. 程序实现方式：
    - 创建一个队列，将根节点放入队列
    - 判断队列是否为空，非空则从队列中取出第一个节点，并判断是否为目标节点
    - 如是目标节点就结束遍历，非不是目标节点则将它所有没有被检测过的子节点加入队列
    - 如队列为空，表示图中并没有目标节点，结束遍历
4. 注意点：
   - 队列：用来存储每一轮遍历得到的节点
   - 标记：用于标记遍历过的节点，防止重复遍历

### DFS: 深度优先遍历 Deepth First Search

1. 深度优先遍历是一种
2. 在上图所示的无向图中，BFS的遍历顺序为：**1，2，5，3，6，9，7，4，8**

## dijkstra算法

## 动态规划 （Dynamic Programming, DP）

- Dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems
- 动态规划是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法，其本质是将一个复杂的问题拆分成一系列子问题
- DP的关键步骤：
  1. 定义**状态**
  2. 定义**状态转移方程**
  3. 找到**边界情况**

### 经典的动态规划题目

#### 1.爬楼梯问题

- 题目：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

- 解析：
  - 定义一个数组`dp[]`来表示爬到某阶楼梯的方法总数，`dp[i]`则表示爬到第`i`阶的方法数，本题目就是求`dp[n]`的值（***定义状态***）
  - 由此我们可以得到，`dp[i] = dp[i-1] + dp[i-2]`（***定义状态转移方程***）
  - 计算边界情况：`dp[0] = 0`, `dp[1] = 1`

- 总结公式：
  $$
  dp(n) = \begin{cases}
  n,\quad n = 0,1,2 \\
  dp(n-1) + dp(n-2),\quad n \geq 3 \\
  \end{cases}
  $$

- 代码：

```JavaScript
const climbStairs = function (n) {
  // 定义一个状态
  const dp = []

  // 定义初始值
  dp[0] = 0
  dp[1] = 1
  dp[2] = 2

  // 定义状态转移方程
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }

  return dp[n]
};
  ```

#### 2.网格问题

- 题目：在一个`m*n`的网格中，机器人从网格左上角向右下角移动，一次只能向下或向右移动一格，问总共有多少种不同的路径？
  
- 解析：j
  - 定义一个二位数组`dp[][]`来表示移动到某个网格的路径总数，`dp[i][j]`则表示第`i`行第`j`列的路径总数，本题目就是求`dp[m][n]`的值（***定义状态***）
  - `dp[i][j] = dp[i][j-1] + dp[i-1][j]`（***定义状态转移方程***）
  - 计算边界情况：`dp[0][0] = 1`, `dp[0][j] = 1`, `dp[i][0] = 1`

- 总结公式：

$$
dp(m,n) = \begin{cases}
1,\quad m=0 \\
1, \quad n=0 \\
dp(m)(n-1) + dp(m-1)(n),\quad m\neq0 \And n\neq0 \\
\end{cases}
$$

- 代码

```JavaScript
const uniquePaths = function (m, n) {
  // 定义一个二维数组表示状态
  const dp = []

  // 定义初始值
  for (let i = 0; i < m; i++) {
    dp.push([])
    dp[i][0] = 1
  }
  for (let i = 0; i < n; i++) {
    dp[0][i] = 1
  }

  // 定义状态转移方程
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }

  return dp[m - 1][n - 1]
};
```

#### 3. 0-1背包问题

#### 参看文章

1. [动态规划40题解析](https://zhuanlan.zhihu.com/p/91582909)
